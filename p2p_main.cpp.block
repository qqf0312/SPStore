
//#include "InterNode.h"
//#include "lib.h"
// #include "rocksdb/db.h"
// #include "rocksdb/options.h"
// #include "rocksdb/slice.h"
#include <grpcpp/grpcpp.h>
#include <json/json.h>
#include <leveldb/db.h>
#include <libblockchain/BlockChainImp.h>
#include <libblockverifier/BlockVerifier.h>
#include <libblockverifier/Common.h>
#include <libblockverifier/ExecutiveContext.h>
#include <libblockverifier/ExecutiveContextFactory.h>
#include <libdevcore/BasicLevelDB.h>
#include <libdevcore/CommonData.h>
#include <libdevcore/CommonJS.h>
#include <libdevcore/FixedHash.h>
#include <libdevcore/TopicInfo.h>
#include <libdevcrypto/Common.h>
#include <libethcore/ABI.h>
#include <libethcore/Block.h>
#include <libethcore/PrecompiledContract.h>
#include <libethcore/Protocol.h>
#include <libethcore/Transaction.h>
#include <libethcore/TransactionReceipt.h>
#include <libexecutive/ExtVM.h>
#include <libinitializer/Initializer.h>
#include <libinitializer/P2PInitializer.h>
#include <libinitializer/SecureInitializer.h>
#include <libmptstate/MPTState.h>
#include <libmptstate/MPTStateFactory.h>
#include <librpc/Rpc.h>
#include <libstorage/LevelDBStorage.h>
#include <libstorage/MemoryTableFactory.h>
#include <libstorage/Storage.h>
#include <libstoragestate/StorageStateFactory.h>
#include <stdlib.h>
#include <sys/time.h>
#include <tbb/concurrent_unordered_map.h>
#include <cassert>
#include <ctime>
#include <fstream>
#include <iostream>
#include <iterator>
#include <memory>
#include <string>
using namespace std;
using namespace dev;
using namespace dev::eth;
using namespace dev::rpc;
using namespace dev::ledger;
using namespace dev::initializer;
using namespace dev::txpool;
using namespace dev::blockverifier;
using namespace dev::blockchain;
using namespace dev::storage;
using namespace dev::mptstate;
using namespace dev::executive;
using namespace ec;

#define THREAD_NUM 1
#define EC_SIZE 10
#define DATACOUNT 3

std::map<u256, std::set<std::string>> contractMap;
std::map<u256, std::set<std::string>> ReadcontractMap;
void putShardPubKeyIntoService(
    std::shared_ptr<Service> service, boost::property_tree::ptree const& _pt)
{
    std::map<GROUP_ID, h512s> shardID2NodeList;
    h512s nodelist;
    int groupid;
    for (auto it : _pt.get_child("group"))
    {
        if (it.first.find("shad.") == 0)
        {
            INITIALIZER_LOG(TRACE)
                << LOG_BADGE("P2PInitializer") << LOG_DESC("initConfig add staticNode")
                << LOG_KV("data", it.second.data());

            std::vector<std::string> s;
            try
            {
                boost::split(s, it.second.data(), boost::is_any_of(":"), boost::token_compress_on);
                if (s.size() != 2)
                {
                    exit(1);
                }
                h512 node;
                node = h512(s[0]);
                nodelist.push_back(node);
                // std::cout << "node" << node << std::endl;
                groupid = (int)((s[1])[0] - '0');
                // std::cout << "groupid" << groupid << std::endl;
            }
            catch (std::exception& e)
            {
                exit(1);
            }
        }
    }
    shardID2NodeList.insert(std::make_pair(groupid, nodelist));
    service->setShardID2NodeList(shardID2NodeList);
}
void putGroupPubKeyIntoService(
    std::shared_ptr<Service> service, boost::property_tree::ptree const& _pt)
{
    std::map<GROUP_ID, h512s> groupID2NodeList;
    h512s nodelist;
    int groupid;
    for (auto it : _pt.get_child("group"))
    {
        if (it.first.find("groups.") == 0)
        {
            std::vector<std::string> s;
            try
            {
                boost::split(s, it.second.data(), boost::is_any_of(":"), boost::token_compress_on);
                if (s.size() != 2)
                {
                    exit(1);
                }
                h512 node;
                node = h512(s[0]);
                nodelist.push_back(node);
                // std::cout << "node" << node << std::endl;
                groupid = (int)((s[1])[0] - '0');
                // std::cout << "groupid" << groupid << std::endl;
            }
            catch (std::exception& e)
            {
                exit(1);
            }
        }
    }
    groupID2NodeList.insert(std::make_pair(groupid, nodelist));
    service->setGroupID2NodeList(groupID2NodeList);
}
static inline double GetTime()
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec + tv.tv_usec / 1e6;
}
class GroupP2PService
{
public:
    GroupP2PService(std::string const& _path)
    {
        boost::property_tree::ptree pt;
        boost::property_tree::read_ini(_path, pt);
        m_secureInitializer = std::make_shared<SecureInitializer>();
        m_secureInitializer->initConfig(pt);
        // std::cout << "m_secureInitializer init" << std::endl;
        m_p2pInitializer = std::make_shared<P2PInitializer>();
        m_p2pInitializer->setSSLContext(
            m_secureInitializer->SSLContext(SecureInitializer::Usage::ForP2P));
        m_p2pInitializer->setKeyPair(m_secureInitializer->keyPair());
        m_p2pInitializer->initConfig(pt);
    }
    P2PInitializer::Ptr p2pInitializer() { return m_p2pInitializer; }
    ~GroupP2PService()
    {
        if (m_p2pInitializer)
        {
            m_p2pInitializer->stop();
        }
    }

private:
    P2PInitializer::Ptr m_p2pInitializer;
    SecureInitializer::Ptr m_secureInitializer;
};
class ECP2PService
{
public:
    ECP2PService(std::string const& _path)
    {
        boost::property_tree::ptree pt;
        boost::property_tree::read_ini(_path, pt);
        m_secureInitializer = std::make_shared<SecureInitializer>();
        m_secureInitializer->initConfig(pt);
        // std::cout << "m_secureInitializer init" << std::endl;
        m_p2pInitializer = std::make_shared<P2PInitializer>();
        m_p2pInitializer->setSSLContext(
            m_secureInitializer->SSLContext(SecureInitializer::Usage::ForP2P));
        m_p2pInitializer->setKeyPair(m_secureInitializer->keyPair());
        m_p2pInitializer->initConfig(pt);
    }
    P2PInitializer::Ptr p2pInitializer() { return m_p2pInitializer; }
    ~ECP2PService()
    {
        if (m_p2pInitializer)
        {
            m_p2pInitializer->stop();
        }
    }

private:
    P2PInitializer::Ptr m_p2pInitializer;
    SecureInitializer::Ptr m_secureInitializer;
};

void thread_insert_txs_task(dev::rpc::Rpc* rpcService)
{
    int deploy_len = 0;
    Json::Reader reader;
    Json::Value root;
    vector<std::string> transaction_cons;
    vector<Transaction::Ptr> transactions;
    vector<std::string> transaction_con;
    // ExecuteVMTestFixture::Ptr evmt = std::make_shared<ExecuteVMTestFixture>();
    int ns = 0;
    ifstream infiles("./deploydata.json", ios::binary);
    assert(infiles.is_open());
    if (reader.parse(infiles, root))
    {
        deploy_len = root.size();
        // auto vm = evmt->getExecutiveInstance();
        for (int i = 0; i < deploy_len; i++)
        {
            std::string tmp = root[i].asString();
            // Transaction::Ptr tx = std::make_shared<Transaction>(
            //     jsToBytes(tmp, OnFailed::Throw), CheckTransaction::Everything);
            // Executive::Ptr e = evmt->getExecutive();
            // e->setVM(vm);
            // evmt->executeTransaction(e, tx);

            // evmt->m_executive_pool.push(e);
            // transactions.push_back(tx);
            // transaction_cons.push_back(tmp);
            rpcService->sendRawTransaction(1, tmp);
        }
        // evmt->m_vminstance_pool.push(vm);
    }
    // for (int i = 0; i < transaction_cons.size(); i++)
    // {
    //     rpcService->sendRawTransaction(1, transaction_cons[i]);
    //     // cout << transaction_con[i] <<endl;
    // }
    // sleep(1);
    infiles.close();

    ifstream infiles2("./deploysmallbank.json", ios::binary);
    assert(infiles2.is_open());
    if (reader.parse(infiles2, root))
    {
        deploy_len = root.size();
        // auto vm = evmt->getExecutiveInstance();
        for (int i = 0; i < deploy_len; i++)
        {
            std::string tmp = root[i].asString();
            // Transaction::Ptr tx = std::make_shared<Transaction>(
            //     jsToBytes(tmp, OnFailed::Throw), CheckTransaction::Everything);
            // Executive::Ptr e = evmt->getExecutive();
            // e->setVM(vm);
            // evmt->executeTransaction(e, tx);
            // evmt->m_executive_pool.push(e);
            // transactions.push_back(tx);
            // transaction_con.push_back(tmp);
            rpcService->sendRawTransaction(1, tmp);
        }
        // evmt->m_vminstance_pool.push(vm);
    }
    // for (int i = 0; i < transaction_con.size(); i++)
    // {
    //     rpcService->sendRawTransaction(1, transaction_con[i]);
    //     // sleep(1);
    //     // cout << transaction_con[i] <<endl;
    // }
    // sleep(5);
    infiles2.close();
    // vector<Transaction::Ptr> transactions_exe;
    int count = 0;
    for (int i = 1; i <= 4; i++)
    {
        // int i  = 1;
        // vector<std::string> txs;
        // if(i != 10)
        // {
        //     sleep(600);
        // }

        std::cout << "number " << i << std::endl;
        // vector<std::string>().swap(transaction_con);
        // transaction_con.swap(vector<Transaction::Ptr>()) ;
        string str1 = "./uniform/";
        string str2 = ".json";
        string str3 = to_string(i);
        str1.append(str3);
        str1.append(str2);
        ifstream infile(str1, ios::binary);
        // ifstream infile("1.json", ios::binary);
        assert(infile.is_open());
        std::string rlpStr;
        std::string response;
        int transaction_count = 0;
        int block_num = 0;
        int current_block_num = 0;

        double dotime = 0;

        int transaction_num_in_block = 0;

        if (reader.parse(infile, root))
        {
            ns = root.size();
            cout << "txs len  = " << ns << endl;
            // if(ns + count > 2000000)
            // {
            //     ns = 2000000 - count ;
            // }
            // else
            // {
            //     count += ns;
            // }

            for (int i = 0; i < ns; i++)
            {
                // sleep(1);
                std::string tmp = root[i].asString();
                transaction_con.push_back(tmp);
                // rpcService->sendRawTransaction(1, tmp);
                // Transaction::Ptr tx = std::make_shared<Transaction>(
                //     jsToBytes(tmp, OnFailed::Throw), CheckTransaction::Everything);
                // transactions_exe.push_back(tx);
                // std::cout << "nonce = " << tx->nonce() << std::endl;
                // string fout="./nonce.txt";
                // std::ofstream out_key(fout,std::ofstream::app);
                // out_key<< tx->nonce() << std::endl;
                // out_key.close();
                // transactions.push_back(tx);
                // txs.push_back(tmp);
                rpcService->sendRawTransaction(1, tmp);
            }
            // for (int i = 0; i < ns; i++)
            // {
            //     rpcService->sendRawTransaction(1, transaction_con[i]);
            // }
        }
        infile.close();
        // for (int i = 0; i < txs.size(); i++)
        // {

        //     if(i %500000 == 0)
        //     {
        //         sleep(3);
        //     }
        //     // sleep(1);
        //     // cout << transaction_con[i] <<endl;
        // }
    }
    // std::thread threads[THREAD_NUM];
    // int patch = transactions_exe.size() / THREAD_NUM;
    // for (int i = 0; i < THREAD_NUM; i++)
    // {
    //     if (i != THREAD_NUM - 1)
    //     {
    //         std::vector<Transaction::Ptr> txs(transactions_exe.begin() + i * patch,
    //             transactions_exe.begin() + (i + 1) * patch);
    //         threads[i] = std::thread(thread_task, i, evmt, txs);
    //     }
    //     else
    //     {
    //         std::vector<Transaction::Ptr> txs(
    //             transactions_exe.begin() + i * patch, transactions_exe.end() - 1);
    //         threads[i] = std::thread(thread_task, i, evmt, txs);
    //     }
    // }
    // for (int i = 0; i < THREAD_NUM; i++)
    // {
    //     threads[i].join();
    // }
    return;
}
int64_t FindSeqInSealers(dev::h512s sealers, dev::h512 mysealer)
{
    for (int i = 0; i < sealers.size(); i++)
    {
        if (mysealer == sealers[i])
        {
            return i;
        }
    }
    return -1;
}
int64_t computeCheckNumber(dev::h512s sealers)
{
    int totalnum = sealers.size();
    return (totalnum - 1) / 3;
}
std::pair<string, int> SplitString(const string& s, const string& c)
{
    string::size_type pos1, pos2;
    pos2 = s.find(c);
    pos1 = 0;
    int rw = 0;
    if (s.substr(pos1, pos2 - pos1) == "1")
    {
        rw = 1;
    }

    pos1 = pos2 + c.size();
    return make_pair(s.substr(pos1), rw);
}
/// load tx's r/rw set (pre-exec)
void injectTxReadSet()
{
    ifstream rsFile("./key.txt");
    ifstream nonceFile("./nonce.txt");
    string fouts = "./block_key.txt";
    std::ofstream out_keys(fouts, std::ofstream::app);
    std::string keyStr, nonceStr;
    vector<string> v;
    while (rsFile >> keyStr && nonceFile >> nonceStr)
    {
        u256 key = u256(nonceStr);
        // std::cout << keyStr<<std::endl;
        std::string value;
        while (keyStr != "---------")
        {
            v.push_back(keyStr);
            rsFile >> keyStr;
            // std::cout << keyStr<<std::endl;
        }
        // std::cout << "read key " <<std::endl;
        for (int i = 0; i < v.size(); i++)
        {
            auto key_pair = SplitString(v[i], "-");
            // std::cout << "rw = " <<key_pair.second << "    hash = " <<  key_pair.first
            // <<std::endl;
            if (key_pair.second == 1)
            {
                contractMap[key].insert(key_pair.first);
                // std::cout << "nonce1 = " << key << "   size = " <<contractMap[key].size() <<std::endl;
            }
            else
            {
                ReadcontractMap[key].insert(key_pair.first);
            }
        }
        vector<string>().swap(v);
    }
    std::cout << "read r/rw set finished" << std::endl;
    rsFile.close();
    // nonceFile.close();
    ifstream blockFile("./block_nonce.txt");    
    std::string blockStr;
    while (blockFile >> blockStr)
    {
        if(blockStr != "******************")
        {
            u256 key = u256(blockStr);
            // std::cout << "nonce2 = " << key << "   size = " <<contractMap[key].size() <<std::endl;
            for(auto it = contractMap[key].begin();it != contractMap[key].end();++it)
            {
                out_keys << *it << std::endl;
            }
        }
        else
        {
            out_keys << "******************" << std::endl;
        }
        
    }
    out_keys.close();
    
}

int main()
{
    injectTxReadSet();
    return 0;
}
