

#include <json/json.h>
#include <libblockchain/BlockChainImp.h>
#include <libblockverifier/Common.h>
#include <libdevcore/CommonData.h>
#include <libdevcore/CommonJS.h>
#include <libdevcore/FixedHash.h>
#include <libdevcore/TopicInfo.h>
#include <libdevcrypto/Common.h>
#include <liberasure-code/common/buffer.h>
#include <libethcore/ABI.h>
#include <libethcore/Block.h>
#include <libethcore/Protocol.h>
#include <libinitializer/Initializer.h>
#include <libinitializer/P2PInitializer.h>
#include <libinitializer/SecureInitializer.h>
#include <librpc/Rpc.h>
#include <stdlib.h>
#include <sys/time.h>
#include <tbb/concurrent_hash_map.h>

#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/serialization/vector.hpp>
#include <cassert>
#include <ctime>
#include <fstream>
#include <iostream>
#include <iterator>
#include <libbloomfilter/bf/all.hpp>
#include <memory>
#include <string>

// #include "Eurasure-P2P.h"
// #include "Eurasure.h"
// #include "Client.h"
#ifdef __cplusplus
extern "C" {
#endif
// qqf修改，把同级的pointproofs删除，对应该文件至libmptstate中的pointproof该添加
//#include "pointproofs.h"
// #include <libmptstate/pointproofs.h>
#ifdef __cplusplus
}
#endif
#include "rocksdb/db.h"
#include "rocksdb/options.h"
#include "rocksdb/slice.h"

using namespace std;
using namespace dev;
using namespace dev::eth;
using namespace dev::rpc;
using namespace dev::ledger;
using namespace dev::initializer;
using namespace dev::txpool;
using namespace dev::blockchain;
using namespace rocksdb;
using namespace bf;

#define EXPECT_EQ(a, b) is_equal(a, b)
#define EXPECT_TRUE(a) is_true(a)
using namespace ceph;

#define INIT_VC_SIZE 5000
#define INIT_MAIN_VC_SIZE 64
#define PARTITION_KEY_MAPPINTO_VC_BYTES_NUM 1
#define BYTES_TO_BITS 4
#define SUB_COMMIT_NUM 16
#define EC_PER_STATE_SIZE 49
long vc_size = 0;
long ec_size = 0;
long bf_size = 0;
long original_size = 0;
long hash_function_size = 0;

string mainDecIntToHexStr(unsigned int num) {
    string str;
    unsigned int Temp = num / 16;
    int left = num % 16;
    if (Temp > 0)
        str += mainDecIntToHexStr(Temp);
    if (left < 10)
        str += (left + '0');
    else
        str += ('A' + left - 10);
    return str;
}
void is_equal(int i, int j) {
    if (i == j) {
        std::cout << "success" << std::endl;
    } else {
        std::cout << "false" << std::endl;
    }
}
void is_true(bool flag) {
    if (flag) {
        std::cout << "success" << std::endl;
    } else {
        std::cout << "false" << std::endl;
    }
}
// using namespace rocksdb;
// using namespace ec;

#define THREAD_NUM 1
#define EC_SIZE 10
#define DATACOUNT 3
// pointproofs_params pointproofs_param;
// pointproofs_params sub_pointproofs_param;

NodeID mynodeId;
static inline double GetTime() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return tv.tv_sec + tv.tv_usec / 1e6;
}
int computePostion(const std::string &posStr, int mod) {
    long res = 0;
    for (int i = 0; i < 4; ++i) {
        // res += data[i] * 2;
        if (posStr[i] >= 'A' && posStr[i] <= 'Z') {
            res = (res * 16 + (posStr[i] - 'A') + 10) % mod;
        }
        if (posStr[i] >= 'a' && posStr[i] <= 'z') {
            res = (res * 16 + (posStr[i] - 'a') + 10) % mod;
        }
        if (posStr[i] >= '0' && posStr[i] <= '9') {
            res = (res * 16 + (posStr[i] - '0')) % mod;
        }
    }
    return res % mod;
}

int maxChunkLen(std::map<int, std::map<int, std::string>> const &states) {
    int max_len = 0;
    for (auto it = states.begin(); it != states.end(); ++it) {
        int len = 0;
        for (auto sub_it = it->second.begin(); sub_it != it->second.end();
             ++sub_it) {
            len += 1;
        }
        // std::cout << "len = " << len << std::endl;
        if (len > max_len)
            max_len = len;
    }
    return max_len;
}

void thread_tps_task(std::shared_ptr<BlockChainInterface> chainManager) {
    int step = 10000;
    int64_t txs_num = 0;
    int64_t current_txs_num = 0;
    double starttime1 = GetTime();
    double endtime1 = 0;
    int count = 0;
    ofstream outfile("./tps.txt", ios::app);
    while (current_txs_num < 1000000) {
        current_txs_num = chainManager->totalTransactionCount().first;
        endtime1 = GetTime();
        if (current_txs_num - txs_num >= step) {
            outfile << "  txs = " << current_txs_num - txs_num
                    << "  time = " << (endtime1 - starttime1) << "  tps = "
                    << (current_txs_num - txs_num) / (endtime1 - starttime1)
                    << std::endl;
            starttime1 = GetTime();
            txs_num = current_txs_num;
        }
    }
    outfile.close();
}
void thread_printBlockHeader_task(
    std::shared_ptr<BlockChainInterface> chainManager) {
    ofstream outfile("./BlockHeader.txt", ios::app);
    int64_t block_num = 1;
    while (block_num < 201) {
        while (block_num > chainManager->number()) {
            sleep(1);
        }
        auto block = chainManager->getBlockByNumber(block_num);
        auto header = block->blockHeader();
        outfile << "parentHash = " << header.parentHash() << std::endl;
        outfile << "stateRoot = " << header.stateRoot() << std::endl;
        outfile << "transactionsRoot = " << header.transactionsRoot()
                << std::endl;
        outfile << "receiptsRoot = " << header.receiptsRoot() << std::endl;
        outfile << "dbHash = " << header.dbHash() << std::endl;
        outfile << "number = " << header.number() << std::endl;
        outfile << "timestamp = " << header.timestamp() << std::endl;
        h512s sealers = header.sealerList();
        for (int i = 0; i < sealers.size(); i++) {
            outfile << "sealer " << i << "  " << sealers[i] << std::endl;
        }
        outfile << std::endl;
        block_num++;
    }
    outfile.close();
}
class ECP2PService {
  public:
    ECP2PService(std::string const &_path) {
        boost::property_tree::ptree pt;
        boost::property_tree::read_ini(_path, pt);
        m_secureInitializer = std::make_shared<SecureInitializer>();
        m_secureInitializer->initConfig(pt);
        // std::cout << "m_secureInitializer init" << std::endl;
        m_p2pInitializer = std::make_shared<P2PInitializer>();
        m_p2pInitializer->setSSLContext(
            m_secureInitializer->SSLContext(SecureInitializer::Usage::ForP2P));
        m_p2pInitializer->setKeyPair(m_secureInitializer->keyPair());
        m_p2pInitializer->initConfig(pt);
    }
    P2PInitializer::Ptr p2pInitializer() { return m_p2pInitializer; }
    ~ECP2PService() {
        if (m_p2pInitializer) {
            m_p2pInitializer->stop();
        }
    }

  private:
    P2PInitializer::Ptr m_p2pInitializer;
    SecureInitializer::Ptr m_secureInitializer;
};
void thread_insert_txs_task(dev::rpc::Rpc *rpcService) {
    int deploy_len = 0;
    Json::Reader reader;
    Json::Value root;
    vector<std::string> transaction_cons;
    vector<Transaction::Ptr> transactions;
    vector<std::string> transaction_con;
    // ExecuteVMTestFixture::Ptr evmt =
    // std::make_shared<ExecuteVMTestFixture>();
    int ns = 0;
    // if (mynodeId ==
    //     h512("6010ad7bf2a76c3563b07f40ec0a98472e34c3dec9850ef03a183fc5cfa473f1b149f8358c5"
    //          "6d9b20bbca911b6159eac01b3ffeb2930ee629eee79c95e00e1e0"))
    // {
    ifstream infiles("./deploysmallbank_2021.json", ios::binary);
    assert(infiles.is_open());
    if (reader.parse(infiles, root)) {
        deploy_len = root.size();
        for (int i = 0; i < deploy_len; i++) {
            std::string tmp = root[i].asString();

            rpcService->sendRawTransaction(1, tmp);
        }
    }

    // sleep(1);
    infiles.close();

    // ifstream infiles2("./deploysmallbank.json", ios::binary);
    // assert(infiles2.is_open());
    // if (reader.parse(infiles2, root))
    // {
    //     deploy_len = root.size();
    //     // auto vm = evmt->getExecutiveInstance();
    //     for (int i = 0; i < deploy_len; i++)
    //     {
    //         std::string tmp = root[i].asString();

    //         rpcService->sendRawTransaction(1, tmp);
    //     }
    // }

    // // sleep(1);
    // infiles2.close();
    // }

    for (int i = 1; i < 7; i++) {
        std::cout << "number " << i << std::endl;
        string str1 = "tx";
        string str2 = ".json";
        string str3 = to_string(i);
        // qqf
        // str1.append(str3);
        str1.append(str2);
        ifstream infile(str1, ios::binary);
        assert(infile.is_open());
        std::string rlpStr;
        std::string response;
        int transaction_count = 0;
        int block_num = 0;
        int current_block_num = 0;

        double dotime = 0;

        int transaction_num_in_block = 0;

        if (reader.parse(infile, root)) {
            ns = root.size();
            cout << "txs len  = " << ns << endl;
            for (int i = 0; i < ns; i++) {
                // sleep(1);
                std::string tmp = root[i].asString();
                // rpcService->sendRawTransaction(1, tmp);
                // Transaction::Ptr tx = std::make_shared<Transaction>(
                //     jsToBytes(tmp, OnFailed::Throw),
                //     CheckTransaction::Everything);
                // transactions_exe.push_back(tx);
                // std::cout << "nonce = " << tx->nonce() << std::endl;
                // string fout="./nonce.txt";
                // std::ofstream out_key(fout,std::ofstream::app);
                // out_key<< tx->nonce() << std::endl;
                // out_key.close();
                // transactions.push_back(tx);
                // txs.push_back(tmp);
                rpcService->sendRawTransaction(1, tmp);
            }
        }
        infile.close();
        // for (int i = 0; i < txs.size(); i++)
        // {

        //     if(i %500000 == 0)
        //     {
        //         sleep(3);
        //     }
        //     // sleep(1);
        //     // cout << transaction_con[i] <<endl;
        // }
    }
    // }
    // std::thread threads[THREAD_NUM];
    // int patch = transactions_exe.size() / THREAD_NUM;
    // for (int i = 0; i < THREAD_NUM; i++)
    // {
    //     if (i != TH
    return;
}

void putGroupPubKeyIntoService(std::shared_ptr<Service> service,
                               boost::property_tree::ptree const &_pt) {
    std::map<GROUP_ID, h512s> groupID2NodeList;
    h512s nodelist;
    int groupid;
    for (auto it : _pt.get_child("group")) {
        if (it.first.find("groups.") == 0) {
            std::vector<std::string> s;
            try {
                boost::split(s, it.second.data(), boost::is_any_of(":"),
                             boost::token_compress_on);
                if (s.size() != 2) {
                    exit(1);
                }
                h512 node;
                node = h512(s[0]);
                nodelist.push_back(node);
                groupid = (int)((s[1])[0] - '0');
            } catch (std::exception &e) {
                exit(1);
            }
        }
    }
    groupID2NodeList.insert(std::make_pair(groupid, nodelist));
    service->setGroupID2NodeList(groupID2NodeList);
}

// std::map<int, std::map<int, std::string>>
// initTestStates(std::shared_ptr<ec::Eurasure> eurasure,
//     rocksdb::DB* bf_db, unsigned int block_number, hasher const& h,
//     rocksdb::DB* before_db)
// {
//     double starttime = GetTime();
//     // int block_number = 0;

//     // for (int block_number = 0; block_number < 10; block_number++) {
//     std::hash<unsigned int> block_hash;
//     unsigned int seed = block_hash(block_number);
//     std::mt19937 generator(seed);
//     uniform_int_distribution<long long> dist(1000, 2000);
//     size_t state_size = dist(generator);
//     // size_t state_size = 1000;
//     // std::cout << "block " << block_number << " state num = " << state_size
//     << std::endl; basic_bloom_filter bf(h, 3000);
//     // pointproofs_value* values = new pointproofs_value[INIT_VC_SIZE];
//     // memcpy(values, template_values, sizeof(template_values) *
//     INIT_VC_SIZE);
//     // bf_db->Put(WriteOptions(), mainDecIntToHexStr(block_number)+"_num",
//     // mainDecIntToHexStr(state_size));
//     std::map<int, std::map<int, std::string>> position_mapinto_accounts;
//     seed = block_hash(block_number);
//     std::mt19937 rand_num(seed);
//     // std::string proof(49, '9');
//     for (size_t i = 0; i < state_size; i++)
//     {
//         // int key = i;
//         std::string key_str =
//         sha256(boost::lexical_cast<string>(rand_num())).hex();

//         // std::cout << "initTestStates key = " << key_str << std::endl;
//         // std::string k = key_str;
//         int value = i;
//         char* tmp = (char*)malloc(64 * sizeof(char));
//         std::string db_key = mainDecIntToHexStr(block_number);
//         db_key.append(key_str);
//         // std::cout << "before_db write key=" << db_key << std::endl;
//         before_db->Put(WriteOptions(), db_key, mainDecIntToHexStr(value));
//         int position = computePostion(key_str, SUB_COMMIT_NUM);

//         int sub_position = computePostion(key_str, INIT_VC_SIZE);
//         // if (i == 0)
//         // {
//         //     std::cout << "keystr = " << key_str << "   value = " << value
//         << std::endl;
//         //     std::cout << "initTestStates block_number = " << block_number
//         //               << "  group = " << position << "   sub_position = "
//         << sub_position
//         //               << std::endl;
//         // }

//         sprintf(tmp, "%s%4d", key_str.substr(0, 32).c_str(), value);
//         std::string strtmp = std::string(tmp, tmp + strlen(tmp));
//         // strtmp.append(proof);

//         // std::cout << "strtmp = " << strtmp<< std::endl;
//         // std::cout << "key_str = " << key_str << "  belong to group " <<
//         position << " position =
//         // " << mainDecIntToHexStr(sub_position) << std::endl;
//         if (position_mapinto_accounts.count(position) != 0)
//         {
//             if (position_mapinto_accounts[position].count(sub_position) != 0)
//             {
//                 position_mapinto_accounts[position][sub_position] =
//                     position_mapinto_accounts[position][sub_position].append(strtmp);
//             }
//             else
//             {
//                 position_mapinto_accounts[position].insert(make_pair(sub_position,
//                 strtmp));
//             }
//         }
//         else
//         {
//             std::map<int, std::string> sets;
//             sets.insert(make_pair(sub_position, strtmp));
//             position_mapinto_accounts.insert(make_pair(position, sets));
//         }
//         // original_size = original_size + key_str.length() +
//         // boost::lexical_cast<string>(value).length(); free(tmp); std::cout
//         << "key_str = " <<
//         // k.substr(0, 32) << std::endl;
//         bf.add(key_str.substr(0, 32));
//         // bf.add(i);
//     }

//     // serialize bloom filter
//     // hasher h = bf.hasher_function();
//     bitvector b = bf.storage();
//     std::stringstream ofs;
//     boost::archive::binary_oarchive oa(ofs);
//     // std::stringstream hash_ofs;
//     // boost::archive::binary_oarchive hash_oa(hash_ofs);
//     // hash_oa << h;
//     oa << b;
//     // bf_size += ofs.str().length() - hash_ofs.str().length();
//     // bf_size += 4;
//     // hash_function_size += hash_ofs.str().length();
//     bf_db->Put(WriteOptions(), mainDecIntToHexStr(block_number), ofs.str());
//     ofs.str("");
//     ofs.clear();
//     // hash_ofs.str("");
//     // hash_ofs.clear();
//     return position_mapinto_accounts;
// }
// void test_ec(std::shared_ptr<ec::Eurasure> eurasure, int block_number,
//     std::map<int, std::map<int, std::string>>& states)
// {

//     for (auto it = states.begin(); it != states.end(); ++it)
//     {

//         eurasure->saveChunk(it->second, block_number, it->first);

//     }
//     eurasure->makeMerkleRoot(block_number);
//     eurasure->setCompleteCodingEpoch(block_number);
//     std::cout << "finish ec " << std::endl;
// }
// void readChunkFromDB(
//     int block_number, int group_num, int pos, std::vector<std::string>&
//     v,rocksdb::DB* test_db)
// {
//     for (int i = 0; i < group_num; i++)
//     {
//         std::string db_key =
//         mainDecIntToHexStr(block_number)+'|'+mainDecIntToHexStr(i) + "," +
//         mainDecIntToHexStr(pos); std::string db_value;
//         test_db->Get(ReadOptions(), db_key, &db_value); if (db_value.length()
//         == 0)
//         {
//             std::cout << "db_key = " << db_key << std::endl;
//             std::cout << "db_value.length() = 0" << std::endl;
//             exit(0);
//         }
//         // if (i == 8 && pos == 4)
//         // {
//         //     std::cout << "readChunkFromDB   hash = " <<
//         sha256(db_value).hex() << std::endl;
//         // }
//         v.push_back(db_value);
//     }
// }
// bool verifyChunkMerkleRoot(
//     std::vector<std::string>& level_to_chunk, int block_number, int
//     chunk_pos, int group_id,rocksdb::DB* test_db)
// {
//     std::string merkleroot;
//     string mid = "+";
//     std::string left, right, values;
//     std::string roots = "";
//     std::string key_root = mainDecIntToHexStr((unsigned int)block_number)
//                                .append(mid.append(mainDecIntToHexStr((unsigned
//                                int)chunk_pos)));
//     test_db->Get(ReadOptions(), key_root, &merkleroot);
//     std::cout << "merkleroot =" << merkleroot << std::endl;

//     values = level_to_chunk[0];
//     // left = sha256(level_to_chunk[0]).hex();
//     // right = sha256(level_to_chunk[1]).hex();
//     // values = sha256(left.append(right)).hex();
//     int pos = group_id;
//     bool flag =false;
//     for (int i = 1; i < level_to_chunk.size(); ++i)
//     {
//         if (!flag)
//         {
//             if (pos % 2 == 1)
//             {
//                 left = level_to_chunk[i];
//                 right = sha256(values).hex();
//                 values = sha256(left.append(right)).hex();
//             }
//             else
//             {
//                 left = sha256(values).hex();
//                 right = level_to_chunk[i];
//                 values = sha256(left.append(right)).hex();
//             }
//             flag = true;
//         }
//         else
//         {
//             if (pos % 2 == 1)
//             {
//                 left = level_to_chunk[i];
//                 right = values;
//                 values = sha256(left.append(right)).hex();
//                 // printf("verifyChunkMerkleRoot ---hash(hash(%s), hash(%s))
//                 =>%s\n", left.c_str(),
//                     right.c_str(), values.c_str());
//             }
//             else
//             {
//                 left = values;
//                 right = level_to_chunk[i];
//                 values = sha256(left.append(right)).hex();
//                 // printf("verifyChunkMerkleRoot ---hash(hash(%s), hash(%s))
//                 =>%s\n", left.c_str(),
//                     right.c_str(), values.c_str());
//             }
//         }

//         pos /= 2;
//     }
//     roots = values;

//     std::cout << "verifyChunkMerkleRoot  " << roots << std::endl;
//     assert(roots == merkleroot);
//     std::cout << level_to_chunk[0] << std::endl;
//     std::cout << "verifyChunkMerkleRoot successfully!" << std::endl;
//     return roots == merkleroot ? true : false;
// }
// std::vector<std::string> readChunkAndComputeMerkleHashs(
//     int block_number, int chunk_pos, int group_id,rocksdb::DB* test_db)
// {
//     std::vector<std::string> v;
//     std::vector<std::string> res;

//     readChunkFromDB(block_number, 16, chunk_pos, v,test_db);

//     int pos = group_id;
//     // std::cout << "start pos = " << pos << std::endl;
//     res.push_back(v[group_id]);
//     if (pos % 2 == 0)
//     {
//         if (pos == v.size() - 1)
//             res.push_back("");
//         else
//             res.push_back(sha256(v[group_id + 1]).hex());
//     }
//     else
//         res.push_back(sha256(v[group_id - 1]).hex());

//     pos /= 2;

//     std::vector<std::string> new_merkle;
//     bool flag = true;
//     while (new_merkle.size() > 1 || flag)
//     {
//         std::cout << "pos = " << pos << "  new_merkle.size() = " <<
//         new_merkle.size() << std::endl; if (flag)
//         {
//             if (v.size() % 2 == 1)
//                 v.push_back("");
//             flag = false;
//             vector<string> result;

//             for (int i = 0; i < v.size(); i += 2)
//             {
//                 string var1 = sha256(v[i]).hex();
//                 string var2 = sha256(v[i + 1]).hex();
//                 string hash = sha256(var1 + var2).hex();
//                 result.push_back(hash);
//             }
//             new_merkle = result;
//         }
//         else
//         {
//             if (new_merkle.size() % 2 == 1)
//                 new_merkle.push_back("");

//             vector<string> result;

//             for (int i = 0; i < new_merkle.size(); i += 2)
//             {
//                 // std::cout << "pos = " <<pos <<  "; i = " << i <<
//                 std::endl;
//                 // std::cout << "pos & 1 == 0 && pos == i = " <<(pos & 1 == 0
//                 && pos == i) << std::endl;
//                 // std::cout << "pos & 1 == 1 && pos == i + 1 = " <<(pos & 1
//                 == 1 && pos == i + 1) << std::endl; if (pos %2  == 0 && pos
//                 == i)
//                 {
//                     res.push_back(new_merkle[i + 1]);
//                 }
//                 else
//                 {
//                     if (pos %2 == 1 && pos == i + 1)
//                     {
//                         res.push_back(new_merkle[i]);
//                     }
//                 }

//                 string var1 = new_merkle[i];
//                 string var2 = new_merkle[i + 1];
//                 string hash = sha256(var1 + var2).hex();
//                 printf("---readChunkAndComputeMerkleHashs hash(hash(%s),
//                 hash(%s)) => %s\n",
//                     new_merkle[i].c_str(), new_merkle[i + 1].c_str(),
//                     hash.c_str());
//                 result.push_back(hash);
//             }
//             pos /= 2;
//             std::cout << "pos = " << pos << std::endl;
//             new_merkle = result;
//         }
//     }
//     // for(int i = 0;i < res.size(); ++i)
//     // {
//     //     if(i == 0)
//     //     std::cout << "res hash = " << sha256(res[i]).hex() << std::endl;
//     //     else
//     //     std::cout << "res hash = " << res[i] << std::endl;
//     // }
//     return res;
// }
// std::string constructMerkleRoot(int pos, int group_num, int
// block_number,rocksdb::DB* test_db)
// {
//     std::vector<string> v;
//     readChunkFromDB(block_number, group_num, pos, v,test_db);

//     vector<string> new_merkle;
//     bool flag = true;
//     while (new_merkle.size() > 1 || flag)
//     {
//         if (flag)
//         {
//             if (v.size() % 2 == 1)
//                 v.push_back("");
//             flag = false;
//             vector<string> result;

//             for (int i = 0; i < v.size(); i += 2)
//             {
//                 string var1 = sha256(v[i]).hex();
//                 string var2 = sha256(v[i + 1]).hex();
//                 string hash = sha256(var1 + var2).hex();
//                 printf("constructMerkleRoot ---hash(hash(%s), hash(%s))
//                 =>%s\n", var1.c_str(),
//                     var2.c_str(), hash.c_str());
//                 result.push_back(hash);
//             }
//             new_merkle = result;
//         }
//         else
//         {
//             if (new_merkle.size() % 2 == 1)
//                 new_merkle.push_back("");

//             vector<string> result;

//             for (int i = 0; i < new_merkle.size(); i += 2)
//             {
//                 string var1 = new_merkle[i];
//                 string var2 = new_merkle[i + 1];
//                 string hash = sha256(var1 + var2).hex();
//                 printf(" constructMerkleRoot ---hash(hash(%s), hash(%s)) =>
//                 %s\n",
//                     new_merkle[i].c_str(), new_merkle[i + 1].c_str(),
//                     hash.c_str());
//                 result.push_back(hash);
//             }
//             new_merkle = result;
//         }
//     }
//     return new_merkle[0];
// }
// void merkletest(rocksdb::DB* test_db)
// {
//     int data_num = 16;
//     vector<string> v(data_num, "");
//     for (int i = 0; i < 1000; ++i)
//     {
//         for (int k = 0; k < data_num * 5; ++k)
//         {
//             // v[i] = to_string(i);
//             // std::string s1= to_string(i / 5);
//             // std::string s2 ="+";
//             // std::string s3 =
//             test_db->Put(WriteOptions(),
//                 mainDecIntToHexStr(i)+'|'+mainDecIntToHexStr(k / 5) + "," +
//                 mainDecIntToHexStr(k % 5), mainDecIntToHexStr(k));
//         }
//         for (int j = 0; j < 4 + 1; j++)
//         {
//             std::string root = constructMerkleRoot(j, data_num, i,test_db);
//             string mid = "+";
//             std::string key = mainDecIntToHexStr((unsigned int)i)
//                                   .append(mid.append(mainDecIntToHexStr((unsigned
//                                   int)j)));
//             // std::cout << "constructMerkleRoot key = " << key << "     root
//             = " << root <<
//             // std::endl;

//             test_db->Put(WriteOptions(), key, root);
//         }

//         for(int k = 0; k < data_num * 5; ++k)
//         {
//             std::vector<std::string> v = readChunkAndComputeMerkleHashs(i,k %
//             5,k / 5,test_db); verifyChunkMerkleRoot(v,i,k % 5,k / 5,test_db);
//         }
//     }
// }
int main(int argc, char *argv[]) {
    // // tests();
    // rocksdb::Options options;
    // options.create_if_missing = true;
    // rocksdb::DB* vc_db;
    // rocksdb::Status status = rocksdb::DB::Open(options, "./vcstorage/",
    // &vc_db); merkletest(vc_db); return 0;

    std::shared_ptr<dev::initializer::Initializer> initialize =
        std::make_shared<dev::initializer::Initializer>();
    initialize->init("./config.ini");

    // boost::property_tree::ptree ecpt;
    // boost::property_tree::read_ini("./configec.ini", ecpt);
    // ECP2PService ecP2Pservice("./configec.ini");
    // auto Ecp2pService = ecP2Pservice.p2pInitializer()->p2pService();
    // putGroupPubKeyIntoService(Ecp2pService, ecpt);
    // Ecp2pService->start();
    // GROUP_ID ecId = std::stoi(ecpt.get<std::string>("group.group_id",
    // "group"));
    auto nodeIdstr = asString(contents("conf/node.nodeid"));
    // PROTOCOL_ID ECId = getGroupProtoclID(ecId, ProtocolID::ECProtocol);

    NodeID nodeId = NodeID(nodeIdstr.substr(0, 128));
    std::cout << "nodeid = " << nodeId << std::endl;
    mynodeId = nodeId;
    // ec::EurasureP2P* p2pHandler = new ec::EurasureP2P(nodeId, Ecp2pService,
    // ECId);

    // auto secureInitializer = initialize->secureInitializer();
    auto ledgerManager = initialize->ledgerInitializer()->ledgerManager();
    auto chainManager = ledgerManager->blockChain(1);
    auto consensusP2Pservice = initialize->p2pInitializer()->p2pService();
    auto rpcService = new dev::rpc::Rpc(ledgerManager, consensusP2Pservice);
    // auto consensusManager = ledgerManager->consensus(1);
    auto blockVerifierManager = ledgerManager->blockVerifier(1);
    // Client* client = new Client(chainManager);
    // client->initClient();
    // h512s NodeLists = {
    //     h512("6010ad7bf2a76c3563b07f40ec0a98472e34c3dec9850ef03a183fc5cfa473f1b149f8358c56d9b20bbca"
    //          "911b6159eac01b3ffeb2930ee629eee79c95e00e1e0"),
    //     h512("fc31df672016011f4390b13ae8418f2366ffef30bfc341c88772bf7e039728cbe86916cef3ce5196b94df"
    //          "c1e4f3d89b7f2d255970ff0630a9f9ba2d20b7a0838"),
    //     h512("88ddaf6a89af6cc5afecccc40c48fb73ced7adf310385fe80b23952d76b9b9805cee27a32c4efddda4b65"
    //          "5ace355a92eaa9a8c5caca78c3fa7a873f73bf5aba7"),
    //     h512("28fd87f50f9a5c2d9936d4c51c53e5ce637b087c40dca953f7df3210a7b8954d466979fb74a25598f7987"
    //          "9876ebc985bc6b9ce10f62861a425ecce62c3fa4e2d"),
    //     h512("3fe3cd4d10fd6b862c9f6439de941bc676930661beb9e15bf692f0b34d45b7b24fd1ed7a9e469dd2604aa"
    //          "d9921da0bdf6b700f9c09fb124c7bb2588dbdf101a7"),
    //     h512("0a634a3406f274792a18b173f8e7a251f8abaf56d1840bdec54ce15a9d1633061d6fa9a7b4b5d5420675b"
    //          "f359046afd61a3bba11d44ad32fc0c3ace6fb416f1d"),
    // };

    // int64_t k = 4;
    // int64_t m = 1;
    // int64_t c = 1;
    // std::cout << "k=" << k << "; m = " << m << "c = " << c << std::endl;
    // std::string dbpath = "./ecstorage/";
    // rocksdb::Options options;
    // options.create_if_missing = true;
    // rocksdb::DB* vc_db;
    // rocksdb::Status status = rocksdb::DB::Open(options, "./vcstorage/",
    // &vc_db); assert(status.ok()); rocksdb::DB* before_ec_db; status =
    // rocksdb::DB::Open(options, "./beforeecstorage/", &before_ec_db);
    // assert(status.ok());
    // rocksdb::DB* bf_db;
    // status = rocksdb::DB::Open(options, "./bfstorage/", &bf_db);
    // assert(status.ok());
    // // blockVerifierManager->setDB(before_ec_db);
    // int group_size = 16;
    // std::shared_ptr<ec::Eurasure> eurasure =
    // std::make_shared<ec::Eurasure>(k, m, c, nodeId,
    //     NodeLists, dbpath, p2pHandler, vc_db, before_ec_db, chainManager,
    //     group_size);
    // p2pHandler->setEurasure(eurasure);
    // eurasure->InitEurasure();
    // int count = 1;
    // basic_bloom_filter bf(0.01, 3000);
    std::thread insert_thread;
    // if (nodeId ==
    // h512("6010ad7bf2a76c3563b07f40ec0a98472e34c3dec9850ef03a183fc5cfa473f1b149f8358c5"
    //                    "6d9b20bbca911b6159eac01b3ffeb2930ee629eee79c95e00e1e0"))
    // {
    // std::cout <<"1111" << std::endl;
    insert_thread = std::thread(thread_insert_txs_task, rpcService);
    // }

    while (1) {
        // int block_number = chainManager->number();
        // if (count < block_number)
        // {
        //     // if (count == 2)
        //     // {
        //     auto states =
        //         initTestStates(eurasure, bf_db, count, bf.hasher_function(),
        //         before_ec_db);
        //     test_ec(eurasure, count, states);
        //     int sizes = count;
        //     // if (count > 3)
        //     // {
        //     //     int sizes = count - 3;
        //     std::hash<unsigned int> block_hash;
        //     unsigned int seed = block_hash(sizes);
        //     std::mt19937 rand_num(seed);
        //     sha256(boost::lexical_cast<string>(rand_num())).hex();
        //     std::string key =
        //     sha256(boost::lexical_cast<string>(rand_num())).hex();

        //     std::string block_num_str = mainDecIntToHexStr(sizes);
        //     std::string bf_str;
        //     bf_db->Get(ReadOptions(), block_num_str, &bf_str);
        //     std::stringstream ifs(bf_str);
        //     boost::archive::binary_iarchive ia(ifs);
        //     bitvector b1;
        //     ia >> b1;
        //     std::cout << "block num = " << sizes << "key = " << key <<
        //     std::endl; basic_bloom_filter obfc(bf.hasher_function(), b1); if
        //     (obfc.lookup(key.substr(0,32)))
        //     {
        //         std::string str = eurasure->getState(sizes, key);
        //         // std::cout << "str = " << str << std::endl;
        //         if (str.length() >= 183)
        //             std::cout << "read value = " <<
        //             eurasure->getKVAndProof(str, key, sizes)
        //                       << std::endl;
        //         else
        //         {
        //             std::cout << "read value = " << str << std::endl;
        //         }
        //         if (nodeId ==
        //         h512("6010ad7bf2a76c3563b07f40ec0a98472e34c3dec9850ef03a183fc5cfa473f"
        //                            "1b149f8358c5"
        //                            "6d9b20bbca911b6159eac01b3ffeb2930ee629eee79c95e00e1e0"))
        //         {
        //             std::string chunk_data = eurasure->decode(sizes, key);
        //             // std::cout << "decode data = " << chunk_data <<
        //             std::endl;

        //             auto t = eurasure->getKVAndProof(chunk_data, key,sizes);
        //             std::cout << "decode value = " << t << std::endl;
        //         }
        //         // }
        //         // }
        //     }
        //     else
        //     {
        //         std::cout << "state  " << key << "  not in block " <<
        //         block_number << std::endl;
        //     }
        //     // }
        //     count++;
        //     sleep(1);
        // }
    }

    // // tps_thread.join();
    // // block_thread.join();
    //  while (1)
    // {
    // }

    // if (nodeId ==
    // h512("6010ad7bf2a76c3563b07f40ec0a98472e34c3dec9850ef03a183fc5cfa473f1b149f8358c5"
    //                    "6d9b20bbca911b6159eac01b3ffeb2930ee629eee79c95e00e1e0"))
    // {
    insert_thread.join();
    // }

    return 0;
}
